\subsection{Taking advantage of both worlds}

Instead of using a functional-first language for mainly object-oriented tasks, an alternative approach is to use both paradigms and languages side-by-side. Everything related to UI, including views and view models, can still be written in C\#, leveraging its natural object-oriented capabilities in conjunction with the object-oriented frameworks the mobile app environment provides. However, everything "below," in particular the model part of MVVM, can be written in F\# in a functional style.

\cite{bandt_building_2018}, for example, presents an implementation of a local Redux store\footnote{https://redux.js.org/ (retrieved August 8, 2019)} written in F\#, which sits at the core of a C\# Xamarin application. F\# is favored for this specific task over C\# because of its built-in features regarding immutability, structural equality, and its discriminated union type. Features that are not available through C\# or that would come with additional costs attached. However, the sole consumer of the store's features is the C\# mobile app, which is built "around" it. That is possible because, as lined out before, everything in .NET compiles eventually to IL code. So, F\# and C\# projects can be used side-by-side within a single "hybrid" solution.

The F\# compiler has some characteristics that make it even more convenient to use F\# code from within C\#. As \cite[255]{petricek_real_2009} mention, "classes or records with members, \dots\ appear as standard C\# classes and can be used without any trouble."

\begin{listing}[H]
\caption{Defining a Record type in F\#}
\begin{minted}{fsharp}
type Article =
    { Title: string
      Author: string }
\end{minted}
\end{listing}

The F\# Article record can be constructed in C\# as any other C\# class.

\begin{listing}[H]
\caption{Constructing an F\# Record type in C\#}
\begin{minted}{csharp}
var article = new Article("Hello World", "Jane Doe");
\end{minted}
\end{listing}

It is worth noting that the characteristics of an F\# record are preserved even when used from C\#. All of its properties need to be provided during construction; afterwards, they are immutable. On top of that, structural equality is provided, as well.

One of the most powerful features of F\# that C\# is still lacking is the support of discriminated unions. However, discriminated unions "are nothing but a bunch of classes generated by the F\# compiler" (\cite[104]{nunez_mastering_2016}).

\begin{listing}[H]
\caption{Defining a Discriminated Union type in F\#}
\begin{minted}{fsharp}
type ArticleType =
    | Editorial
    | Column of columnist: string
    | Essay
\end{minted}
\end{listing}

For the payload case, the compiler creates a factory method that helps to create the object in C\#.

\begin{listing}[H]
\caption{Constructing an F\# Discriminated Union type in C\#}
\begin{minted}{csharp}
var column = ArticleType.NewColumn("Jane Doe");
\end{minted}
\end{listing}

After all, it is not only technically feasible to use F\# and C\# side-by-side, but this approach also offers an opportunity to introduce functional programming with F\# for many software development teams in the first place. Existing object-oriented knowledge, concepts, and code artifacts can continue to be used while solving specific problems with functional programming at the same time.
